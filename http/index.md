## HTTP 概述

### 基于HTTP的组件系统
**客户端 user-agent**  
用户发起行为的工具，即发起一个请求的实体，通常是浏览器。

**Web服务器**  
服务并提供客户端所请求的文档。

**代理 Proxies**  
在服务器和浏览器之间，有许多计算机和其他设备转发了HTTP消息。表现在应用层上的这些被称为**代理 Proxies**。代理可以表现的透明，又可以不透明。  
代理主要作用：
- `缓存`（可以是公开的也可以是私有的，像浏览器的缓存）
- `过滤`（像反病毒扫描，家长控制）
- `负载均衡`（让多个服务器服务不同的请求）
- `认证`（对不同资源进行权限管理）
- `日志记录`（允许存储历史消息）

### HTTP基本性质
- `简单的`：被设计的简单易读。HTTP报文能够被人读懂，还允许简单测试。
- `可扩展的`：只要服务器和客户端就新的headers达成语义一致，新功能就可以被轻松加入进来。
- `无状态，有会话的`：同一个连接中，两个执行成功的请求之间是没有关系的。
  > HTTP本质是无状态的，使用`Cookies`可以创建有状态的会话。
- `HTTP和连接`：HTTP并不需要其底层的传输层协议是面向连接的，只需要他是可靠的或不丢失消息的（至少返回错误）。_两个常用的传输层协议：TCP是可靠的，UDP不是_。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。  
  HTTP/1.0为每一个请求/响应都打开一个TCP连接，导致了2个缺点：打开一个TCP连接需要多次往返消息传递，因此速度慢。但当多个消息周期性发送时，这样就变得更加高效：暖连接比冷连接更高效。  
  HTTP/1.1引入了流水线（被证明难以实现）和持久连接：底层TCP连接可以通过Connection头部来被部分控制。  
  HTTP/2通过一个连接复用消息的方式来让这个连接始终保持为暖连接。

### HTTP可以控制的常见特性
- `缓存`
  服务器能告诉代理和客户端哪些文件需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。
- `开放同源限制`
  为了防止网络窃听和其他隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于**相同来源**的网页才能获取网站的全部信息。HTTP可以通过修改头部来开放这样的限制。
- `认证`
  一些网页能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用`Authenticate`相似的头部即可，或用`HTTP Cookies`来设置指定的会话。
- `代理和隧道`
  通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实IP地址。因此HTTP请求就要通过代理越过这个网络屏障。但并非所有的代理都是HTTP代理。例如，SOCKS协议的代理就运作在更底层，一些像FTP这样的协议也能够被它们处理。
- `会话`
  使用`HTTP Cookies`允许你用一个服务端的状态发起请求，这就创建了会话。这使得任何网站都能轻松为用户定制展示内容了。

### HTTP报文
请求
```
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```
- 一个HTTP的method（GET，POST,OPTIONS，HEAD来定义客户端的动作行为）
- 要获取的资源的路径，通常是上下文中就很明显的元素资源的URL
- HTTP协议版本号
- 为服务端表达其他消息的可选头部headers
- 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与响应报文的body类似。

响应
```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```
- HTTP协议版本号
- 状态码（status code），告知对应请求执行成功或失败，以及失败的原因。
- 状态消息，这个消息是非权威的状态码描述消息，可以由服务端自行设定。
- HTTP headers，与请求头部类似。
- 可选项，比起请求报文，响应报文中更常见地包含获取的资源body。


## HTTP缓存

### 各种类型的缓存
缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。

两大类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用，私有缓存只能用于单独用户。

浏览器缓存(私有)：浏览器缓存拥有用户通过HTTP下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。

代理缓存(共享)：例如 ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

> 除此之外还有网关缓存，CDN，反向代理缓存和负载均衡器等部署在服务器上，为站点和Web应用提供更好的稳定性、性能和扩展性。

### 缓存操作的目标
常见的HTTP缓存只能存储`GET`响应。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）

### 缓存控制
**Cache-Control头**
`HTTP/1.1`定义的`Cache-Control`头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。
- 禁止进行缓存  
  ```
  Cache-Control: no-store
  Cache-Control: no-cache, no-store
  ```
  > 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
- 强制确认缓存  
  ```
  Cache-Control: must-revalidate
  ```
  > 此方式下，每次有请求发出时，缓存会将此请求发到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本。
- 私有缓存和公共缓存
  ```
  Cache-Control: private
  Cache-Control: public
  ```
  > "public" 指令表示该响应可以被任何中间人缓存。而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
- 缓存过期机制
  ```
  Cache-Control: max-age=31536000
  ```
  > `max-age=<seconds>`表示资源能够被缓存的最大时间

**Pragma头**
`Pragma`是`HTTP/1.0`标准中定义的一个`header`属性，请求中包含`Pragma`的效果跟在头信息中定义`Cache-Control: no-cache`相同，但是HTTP的响应头不支持这个属性。  

### 带Vary头的响应
`Vary` HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还是使用缓存的文件。  
当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。
